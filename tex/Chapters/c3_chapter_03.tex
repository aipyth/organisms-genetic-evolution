%!TEX root = ../thesis.tex
\chapter{Реалізація моделі та аналіз результатів}
\label{chap:practice}

Щось про розділ


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Середовище}

Як основне середовище для розвитку організмів було створено просту реалізацію двовимірного обмеженого неперервного (в обчислювальному сенсі) середовища. Його ініціалізація проводиться низкою параметрів, таких як розміри середовища, розмір та енергетична цінність їжі, частота появи їжі, та інші. Середовище відповідає за низку процедур для моделювання: обробка результатів організмів, обробка колізій об’єктів, оновлення позицій об’єктів та моделювання плину часу в середовищі.

Для обробки колізій та ефективного зберігання об’єктів обрано просторову структуру даних R-Дерево (R-Tree). Ця структура зазвичай використовується для індексації багатовимірної інформації, такої як географічні координати, прямокутники або багатокутники.

Основною ідеєю цієї структури є ідея групування сусідніх об’єктів для представлення їх за допомогою мінімального обмежувального прямокутника на наступному вищому рівні дерева. Тому і має назву R-Tree, як дерево прямокутників.

Ця структура є корисною для практичних задач із просторовою взаємодією. В контексті Python існує бібліотека rtree, що надає інтерфейс до вже реалізованої бібліотеки на C, що встановлюється на систему. Таким чином ми забезпечені достатньою швидкістю пошуку, зміни та інших маніпуляцій об’єктів у просторі.

Їжа грає ключову роль у процесі виживання та розвитку організмів, надаючи потрібний ресурс, що є розподіленим по середовищу. Сам об’єкт їжі є точкою з певним числом, що задає розмір цієї частинки. Кожна ця частинка має певну кількість енергії, що задається константно при ініціалізації середовища. Сама їжа у середовищі з’являється за ймовірнісним процесом. На старті середовища задається параметр для експоненційного розподілу, за яким і з’являються частинки у рівномірно вибраніч точці середовища.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Організми}

Об’єкт організму репрезентує модель біологічного індивіда, що має певний набір характеристик: геном, розмір, швидкіст руху, прискорення, напрямок, енергетичний рівень, вік.

Геном організму задається парами матриць, що слугують вагами та упередженістю нейронної мережі. Сам клас самостійно оперує цією структурою. Єдина річ, яку потрібно задавати тут це шари нейронної мережі та кількість нейронів у них. Більша кількість шарів та нейронів призводить до більшого геному.

Кожен організм може думати за допомогою цієї мережі. Результат його праці це команда на пересування. Але кожна команда впирається у фізичні обмеження цього організму. Ми обмежуємо його пересування у середовищі задаючи максимальну можливу швидкість, прискорення та зміну напряму. Це є логічним, оскільки і в реальному житті будь-який організм не може змінити свої фізичні характеристики в одну мить. А в моделюванні з дискретним часом нам важливо зберегти якусь подібність до реальності.

На швидкості організм не повинен вміти швидко змінювати напрям. Саме тому додаємо гальмівний ефект від зміни напряму руху:
\[
  v^{(t+1)} = \max(-v_{max}, \min(v_{max}, v^{(t)} + a)) \cdot \frac{1}{1 + d}
\]
На обробку інформації про зовнішній світ у організма повинна якось змінюватися енергія. Так ось і буде вона змінюватися за простим законом. Вводимо коефіцієнт зміни енергії  та будемо задавати зміну енергії так:
\[ E^{(t+1)} = E^{(t)} - \overline{o} \]
Де $\overline{o}$ позначаємо як результат роботи нейронної мережі.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Кодування}

Для генетичних алгоритмів використовують різні методи кодування, щоб представити розв'язки задачі в структурі хромосоми або геному. Типовими прикладами кодувань є: двійкове кодування, цілочисельне кодування, кодування дійсними числами, кодування перестановками та кодування значеннями.

Двійкове кодування представляє рішення за допомогою двійкових цифр       (0 і 1). Якщо простір задачі вимагає дискретних величин, краще використовувати цілочисельне кодування, оскільки воно використовує цілі числа. Кодування перестановок підходить для проблем впорядкування або маршрутизації, оскільки воно передбачає розміщення речей або значень у певному порядку. У складних проблемних просторах, де певні стани або атрибути повинні бути представлені явно, кодування значень, також відоме як пряме кодування, передбачає безпосередній запис значень рішення.

У цій реалізації генетичного алгоритму для представлення геному організму можна конфігурувати різні можливі кодування. Це можливо завдяки правильній структурі коду, що дає можливіть швидко змінювати параметри моделі.

Але найкраще використати кодування дійсними числами. Перевага кодування в дійсних числах полягає в тому, що воно безпосередньо представляє неперервні змінні, що робить його особливо придатним для питань, пов'язаних з оптимізацією неперервного простору, таких як оптимізація ваг нейронних мереж.

Ваги та упередженність нейронної мережі безпосередньо кодуються в геномі організму за допомогою цього кодування в дійсних числах. Клас RealValued дає можливість кодувати та декодувати ваги організму в одновимірний масив геному. Для цього ваги та зсуви вирівнюються та об'єднуються. Для декодування сплющені масиви повертаються до початкових розмірів.

Завдяки такому кодуванню можна ефективно шукати у неперервному просторі оптимальні параметри нейронної мережі організму. Через те, що ваги та упередженність за своєю природою є дійсними числами, це забезпечує простий та ефективний метод оптимізації нейронних мереж. Імітуючи еволюцію біологічних організмів і використовуючи цей процес для вдосконалення моделей машинного навчання, ця методика втілює суть біологічно натхненного навчання.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Генетичні оператори}

Генетичні оператори грають величезну роль у зміні поведінки організмів та продуктивності генетичного алгоритму. Вони дозволяють вивчати можливі рішення проблеми у фазовому просторі рішень або ж перевикористати поточні варіанти для отримання більш кращого. Вибір і конфігурація цих операторів є важливою частиною проектування генетичного алгоритму.

Мутація вносить невеликі випадкові зміни в геноми індивідів, щоб підтримувати її різноманітність. Було запрограмовано різні типи мутації.

NonUniformMutation клас реалізує нерівномірну мутацію, яка змінює гени на основі функції, що зменшується з часом, сприяючи експлуатації, а не дослідженню в подальшому процесі роботи алгоритму. Це дозволяє на кінцевих ітераціях сфокосуватися на отриманні більш точних рішень, а ніж дослідженню простору.

GaussianMutation та UniformMutation є Гауссовую мутацією та рівномірною мутацією, які вносять зміни з нормального розподілу або з рівномірного розподілу відповідно.

Селекція - це процес вибору особин, або батьків, які дадуть потомство у наступному поколінні. Клас TruncationSelection реалізує усічений відбір, який обирає найкращих n особин на основі їхніх значень пристосованості. Цей підхід є простим і ефективним, гарантуючи, що для розмноження будуть обрані найбільш пристосовані особини.

Кросинговер - ще один важливий генетичний оператор. Він дозволяє обмінюватися генетичним матеріалом між батьківськими особинами, створюючи таким чином потомство.

Клас SBXCrossover реалізує імітований двійковий кросинговер (SBX), який імітує поведінку одноточкового кросинговеру в генетичних алгоритмах з двійковим кодуванням в контексті кодування з дійсними значеннями. Він генерує нащадків ближче до батьків [3, 4].

Клас BLXCrossover реалізує змішаний кросовер (BLX), який створює нащадків у діапазоні, визначеному генами батьків і пропорцією, що дозволяє проводити більш значні дослідження [5, 6].

Клас ArithmeticCrossover генерує нащадків, використовуючи лінійну комбінацію генів батьків.

Клас UniformCrossover реалізує простий рівномірний кросинговер, де кожен ген нащадка випадковим чином вибирається від одного з батьків.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Збір даних під час моделювання}

Механізм еволюції реалізовано з використанням об'єктно-орієнтованого підходу. По суті, це конвеєр, який перетворює популяцію організмів на наступне покоління. Цей процес відбувається в основному за допомогою чотирьох ключових кроків: відбору, проходження процесу елітизму, кросинговеру та мутації.

Також важливим параметром є ввімкнення процесу помирання організмів при досягненні критичної області енергії. Таким чином ми можемо отримати стаціонарний генетичний алгоритм, який не потребує переходів між популяціями. Його основна перевага це постійний процес еволюції, помирання індивідів та оптимізації по використанню пам’яті [7].


Було імплементовано комплексну бібліотеку для зручної роботи з дослідженням адаптації організмів до середовища. Підхід при її розробці мав на меті легку параметрицію для впровадження швидких експериментів по моделюванню життя організмів.
Також варто зазначити, що будь-яка частина програми може бути вільно замінена на іншу реалізацію. Тобто більш складні середовища можуть бути легко спровадженні у цей продукт через його модульність. Для дослідження цього проекту було вирішено обмежитися одним середовищем та одним типом організмів. Це дозволило швидко провести аналіз даних, отриманих за допомогою цієї моделі.




\section{Метрики}

Для аналізу поколінь організмів цілком розумно було б використати певний набів метрик, які б показали як поводять себе організми у середовищі, якою є їхня різноманітність та їх рівень розвитку. Використання цих метрик дасть можливість проводити більш обґрунтований та деталізований аналіз.

Однією з таких метрик є пристосованість, що у даній реалізації є не що інше як рівень енергії у організмі. Він надає інформацію про те, наскільки ефективно організм використовує доступні йому ресурси та його здатність адаптуватися до змін у навколишньому середовищі.

Також ми можемо задати метрику максимального та мінімального рівня енергії, що дасть нам більш повну інформацію про різноманітність популяції у використанні ресурсів.

Іншою є метрика співвідношення спожитої їжі до кількості рухів організму. Ця метрика допоможе нам зрозуміти енергоефективність організму, показуючи, наскільки ефективно він використовує отримані від їжі ресурси для своєї активності. Ця метрика обчислюється як відношення кількості рухів до кількості спожитих частинок їжі.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Аналіз впливу параметрів по метрикам}

Розглянемо роботу метрик та порівняємо два різних кросинговера та дві конфігурації нейронної мережі. Як кросинговери візьмемо BLXCrossover та арифметичний кросинговер та візьмемо конфігурації [16, 6, 2] і [16, 12, 6, 2], тобто спробуємо порівняти більш просту та більш складну мережі.


\hide{

Зазвичай третій розділ присвячено опису практичного застосування або 
експериментальної перевірки аналітичних результатів, одержаних у другому 
розділі роботи. Втім, це не обов'язкова вимога, і структура основної 
частини диплому більш суттєво залежить від характеру поставлених завдань. 
Навіть якщо у вас є певне експериментальне дослідження, але його загальний 
опис займає дві сторінки, то краще приєднайте його підроздіром у 
попередній розділ.

При описі експериментальних досліджень необхідно:

\begin{itemize}
\item наводити повний опис експериментів, які проводились, параметрів 
обчислювальних середовищ, засобів програмування тощо;
\item наводити повний перелік одержаних результатів у чисельному вигляді для їх можливої 
перевірки іншими особами;
\item представляти одержані результати у вигляді таблиць та графіків, 
зрозумілих людському оку;
\item інтерпретувати одержані результати з точки зору поставленої задачі 
та загальної проблематики ваших досліджень.
\end{itemize}

У жодному разі не потрібно вставляти у даний розділ тексти 
інструментальних програм та засобів (окрім того рідкісного випадку, коли 
саме тексти програм і є результатом проведення експериментів). За 
необхідності тексти програм наводяться у додатках.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapconclude{\ref{chap:practice}}

Висновки до останнього розділу є, фактично, підсумковими під усім 
дослідженням; однак вони повинні стостуватись саме того, що розглядалось у 
розділі.
